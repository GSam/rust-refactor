\section{Conclusion}\label{C:con}
% Documentation of API is necessary.
This work has explored refactoring and providing tool-support within the context of the Rust programming language. Utilizing existing infrastructure provided by the compiler, this work identifies extensions which help facilitate common automated refactorings. In a more general sense, this work attempts to build upon existing work done on refactoring by documenting specific decisions made in building a refactoring tool (which might normally only be encoded in the source code of an actual tool), and attempting to analyze the decisions made by others.

% Rust provides some unique obstacles in providing automated refactorings...

At the moment the provided tool supports renaming of local and global variables, fields, function arguments, structs, enum and functions (or methods). Beyond renaming, it also allows reification and elision of lifetime parameters for functions and methods and has preliminary support for inlining of local variables. These refactorings in particular highlight the idiosyncrasies of Rust, ensuring that the analyses performed here are some of the first of its kind. The complete limitations of these refactorings are not yet fully known, but there exists a current suite of tests to ensure that there are no obvious flaws in the approach. The presence of bugs in the compiler is a real problem to generality, but without real world use and more contribution to testing, finding these corner cases appears to be difficult.

At the moment, Rust lacks significant refactoring tool-support and evidently requires more work particularly within the compiler to enable further, valuable progress. Although a preliminary tool has been provided, there are many avenues for continuing work and the hope is that this first investigation provides useful insight for future efforts. Understanding the required context and the necessary infrastructure has been a major part of this work. In particular, learning and understanding Rust has been incredibly challenging, as it introduces concepts rarely used elsewhere. Continuation of this work should allow greater focus on implementing a more difficult and comprehensive set of refactorings for Rust.

\section{Appendix}\label{C:appen}
\section{Eclipse refactorings}
\begin{center}
\begin{figure}
\scalebox{0.9}{
\begin{tabular}{ l | l | l }
Rename &
Move &
Extract Method \\
Extract Local Variable &
Extract Constant &
Inline \\
Move Type to New File &
Extract Superclass &
Extract Interface \\
Push Down &
Pull Up &
Extract Class \\ 
Introduce Indirection &
Introduce Factory &
Introduce Parameter \\
Encapsulate Field &
Generalize Declared Type &
Migrate JAR File \\
Change Method Signature &
Convert Anon. Class to Nested &
Convert Local Variable to Field \\
Use Supertype Where Possible &
Introduce Parameter Object &
Infer Generic Type Arguments
\end{tabular}
}
\caption{List of refactorings supported by Eclipse}
\label{Fig:eclipse}
\end{figure}
\end{center}
