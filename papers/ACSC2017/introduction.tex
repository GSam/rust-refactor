\section{Introduction}\label{C:intro}

The Rust programming language reached the 1.0 milestone back in May 2015. Backed by Mozilla and Mozilla Research, Rust is open source and generates a number of contributions from the community. As a modern memory-safe systems programming language, the aim for the language is to provide reliable and efficient systems by combining the performance of low level control, with the convenience and guarantees of higher level constructs. All of this is achieved without a garbage collector or runtime and allows interoperability with no overhead with C. Rust enforces an ownership system to restrict the duplication of references through borrowing and lifetimes, while still aiming for `zero cost abstractions'. Using these techniques, Rust prevents dangling pointers and a whole class of related issues concerning iterator invalidation, concurrency and more.

Refactoring is the act of performing functionality preserving code transformation. Traditionally, these transformations needed to be performed manually, but in recent years, a number of tools to aid and automate refactorings have arisen in many programming languages such as Java or C++ \cite{brown2008tool}. Manual transformations, including editor search-and-replace are potentially prone to error and so performing tool-assisted refactoring which guarantees some measure of correctness can provide much greater confidence in changes.

The main purpose of this work is to produce a proof-of-concept refactoring tool which utilises existing infrastructure made available by the Rust compiler. The idea was to produce a tool which may be run to provide a set of refactorings, which may continue to be extended in the future.

Our refactoring contributions are as follows: (1) Renaming local and global variables, function arguments, fields, functions and methods, structs, and enumerations; (2) inlining local variables; (3) lifetime parameter reification and elision. In particular, the third item was not implemented in any other language until this point. Finally, we outline the challenges involved and evaluate our tool.